#!/bin/sh

# This tool can build a minimal initramfs for network booting.
#
# -- Implementation notes --
#
# * About MODULE NAMING:
#   In order to avoid making 'modinfo' calls, which could be quite slow
#   in some cases (e.g., if building on a different machine with qemu-based
#   CPU emulation), this tool prefers to parse modules.dep and
#   modules.builtin files.
#   However, there is a discrepancy between module names in
#   /sys/modules/<modname> and file names in /lib/modules/<kversion>/.
#   Module names in /sys/modules never have dash characters; undescores
#   are used instead. Whereas file names may have dash or underscore
#   characters.
#   Since we start by probing modules currently in use, we first get
#   module names with undescores only. So we decided to continue
#   using this module naming in the whole process, and at end, when
#   we must copy a selected module to the initramfs root filesystem,
#   we use globbing to find the module file regardless of whether
#   dashes or underscores are used.

check_commands() {
    local cmd
    for cmd in "$@"
    do
        if ! which $cmd >/dev/null
        then
            echo "Failed: command $cmd not found on this system." >&2
            exit 4
        fi
    done
}

check_root() {
    if [ "$(id -u)" -ne 0 ]
    then
        echo "This must be run as 'root' user. Exiting." >&2
        exit 7
    fi
}

check_commands id dirname mktemp head sed grep uname realpath \
               sort tr
check_root

THIS_DIR="$(cd "$(dirname $0)"; pwd)"
TMP_DIR="$(mktemp -d)"
USAGE="""\
USAGE
-----
Generate an initramfs file for the current machine:
<target>$ $0 [..options..] <out-initramfs-file>                  # (A)

Probe modules needed on the target machine, then
build the initramfs from a different build environment:
<target>$ $0 --probe [..options..] > <env-file>                  # (B1)
<build>$ $0 --env <env-file> [..options..] <out-initramfs-file>  # (B2)

Build the initramfs from a different build environment, but
consider the target kernel has all needed modules built in:
<build>$ $0 --no-modules [..options..] <out-initramfs-file>      # (C)

Print the full help message:
$0 --help
"""

DEFAULT_PROTOCOL=$(ls -1 "$THIS_DIR/protocols/" | head -n 1)
LABEL_PROTOCOLS=$(echo $(ls "$THIS_DIR/protocols/") | sed "s/ /|/g")

HELP="""\
$USAGE\

OPTIONS
-------
* --probe:
  Probe-only mode. Checkout the 'Two-steps workflow' below for details.

* --protocol [${LABEL_PROTOCOLS}]:
  By default this tool will build an initramfs booting using \
'${DEFAULT_PROTOCOL}'.
  Use this option to select another one (allowed at step A, B1, and C).

* --no-modules:
  If generating an initramfs file for an embedded system which has all
  needed modules built into the kernel image, you can use this option
  to skip module detection. This will bypass the checks regarding the
  directory at '/lib/modules/<kversion>'.
  This option is not compatible with steps 'B1' and 'B2', since the
  purpose of the env-file is to indicate which modules are needed.
  You may use it with step A or step C.

* --rootfs /path/to/rootfs
  Consider the target OS for which the initramfs is being built is at
  the specified path, not at '/'. Usable only with step B2 or step C.

OUTPUT FORMAT
-------------
The output file generated by step A, B2 or C is an uncompressed cpio
archive. If the kernel supports compressed initramfs archives, e.g.
zstd or gzip archives, feel free to compress it with the appropriate
tool.

DETECTION OF KERNEL MODULES
---------------------------
For generating a valid initramfs file, this program has to probe
which kernel modules are needed for bringing ethernet interfaces up
and for the network filesystem.

This leads to the three workflows described below.

SIMPLE WORKFLOW (A)
-------------------
If you are building the initramfs for the machine currently running,
just use step A. It will probe the modules in use and build the
initramfs file immediately.

TWO-STEPS WORKFLOW (B1+B2)
--------------------------
If you want to build the initramfs-file on another machine (or perhaps
in a different environment, e.g., in a docker container), then:
- First run the tool using option '--probe' on the target machine (step B1);
  this will generate an environment file.
- Then, use option '--env <env-file>' when you run the tool on the build
  machine (step B2). Optionally, use option '--rootfs' to specify the root
  directory of the target system (otherwise, '/' is assumed).

SIMPLIFIED BUILD WORKFLOW (C)
-----------------------------
Workflow C is a simplified version of the two-steps workflow described
above (B1+B2).
If you know that the target OS has all needed modules compiled into the
kernel image for handling the network interfaces and the network filesystem,
then you can bypass the probing step on the target machine and directly
run the build step, specifying option '--no-modules'.
You want want to use option '--rootfs' too in this case.
"""

MESSAGE_SUSPICIOUS_HOST="""\
If you are running this on a build environment different from
the target machine, you should first generate an env-file on this
target machine using the probe-mode."""

MESSAGE_SEE_HELP="""\
See '$0 --help'. Aborting."""

#trap "rm -rf ${TMP_DIR}" EXIT
set -e
# check that we can find the commands we need on this host

kversion=""
mode="build"
env_file=""
protocol=""
modules=""
no_modules=0
rootfs=""
lib_mod_dir=""

# analyse options
while true
do
    case "$1" in
        "-h"|"--help")
            echo "$HELP"
            exit
            ;;
        "--env")
            env_file="$2"
            shift 2
            ;;
        "--protocol")
            protocol="$2"
            shift 2
            ;;
        "--rootfs")
            rootfs="$2"
            shift 2
            ;;
        "--no-modules")
            no_modules=1
            shift
            ;;
        "--probe")
            mode="probe"
            shift
            ;;
        *)
            break
            ;;
    esac
done

parse_var() {
    local var="$1"
    local env_file="$2"
    if ! grep "^${var}[[:space:]]*=" < "$env_file"
    then
        echo __FAILED__
    fi | sed -e "s/^${var}[[:space:]=\"']*//" -e "s/[[:space:]\"']$//"
}

parse_env_file() {
    if [ ! -r "$1" ]
    then
        echo "Could not read the env file at the path specified." \
             "Aborting." >&2
        exit 2
    fi
    kversion=$(parse_var "KVERSION" "$1")
    modules=$(parse_var "MODULES" "$1")
    protocol=$(parse_var "PROTOCOL" "$1")
    if [ "$kversion" = "__FAILED__" -o \
         "$modules" = "__FAILED__" -o \
         "$protocol" = "__FAILED__" ]
    then
        echo "Invalid env file. Use" \
             "'$0 --probe [..options..] > <env-file>'" \
             "on the target machine to generate it." >&2
        exit 2
    fi
    if [ -z "$modules" ]
    then
        no_modules=1
    fi
}

# check usage
if [ "$protocol" != "" ]
then
    if [ ! -d "$THIS_DIR/protocols/$protocol" ]
    then
        echo "Unknown protocol." \
             "Use one of:" $(ls "$THIS_DIR/protocols/") >&2
        echo "Aborting." >&2
        exit 2
    fi
fi

if [ "$mode" = "probe" ]
then
    if [ "$1" != "" ]
    then
        echo "$USAGE" >&2
        exit 2
    elif [ "$env_file" != "" ]
    then
        echo "Don't use option '--env' with the probing mode. Aborting." >&2
        exit 2
    elif [ "$rootfs" != "" ]
    then
        echo "Don't use option '--rootfs' with the probing mode." \
             "Aborting." >&2
        exit 2
    fi
fi

if [ "$mode" = "build" ]
then
    check_commands find chroot cpio

    if [ "$1" = "" -o "$2" != "" ]
    then
        echo "$USAGE" >&2
        exit 2
    fi

    if [ "$env_file" != "" -a "$no_modules" -eq 1 ]
    then
        echo "Options '--env' and '--no-modules' are mutually exclusive." >&2
        echo "The modules are supposed to be defined in the env-file." >&2
        echo "Aborting." >&2
        exit 2
    fi

    if [ "$rootfs" != "" ]
    then
        if [ "$env_file" = "" -a "$no_modules" -eq 0 ]
        then
            echo "Option '--rootfs' must be combined with either" \
                 "'--env' or '--no-modules'." >&2
            echo "$MESSAGE_SEE_HELP" >&2
            exit 2
        fi
    fi

    if [ "$env_file" != "" ]
    then
        saved_protocol="$protocol"
        parse_env_file "$env_file"

        # note: we only tolerate having both options --env and --protocol
        # if they define the same protocol.
        if [ "$saved_protocol" != "" -a "$protocol" != "$saved_protocol" ]
        then
            echo "Options '--env' and '--protocol' are mutually" \
                 "exclusive." >&2
            echo "The protocol is defined in the env-file because" \
                 "changing the protocol may change the list of modules" \
                 "needed." >&2
            echo "You can regenerate an env-file with the right protocol" \
                 "by running the following command on the target" \
                 "machine:" >&2
            echo "$ $0 --probe --protocol $protocol > new-env-file" >&2
            echo "Aborting." >&2
            exit 2
        fi
    fi
fi

if [ "$protocol" = "" ]
then
    protocol=$DEFAULT_PROTOCOL
fi

if [ "$kversion" = "" ]
then
    kversion="$(uname -r)"
    kversion_label="current kernel version '${kversion}'"
else
    kversion_label="the kernel version specified in the env file"
fi

if [ "$rootfs" = "" ]
then
    rootfs="/"
    lib_mod_dir="/lib/modules/$kversion"
else
    if [ -d "$rootfs" ]
    then
        rootfs="$(realpath "$rootfs")"
        lib_mod_dir="$rootfs/lib/modules/$kversion"
    else
        echo "Failed: '$rootfs' not found or not a directory."
        echo "Aborting." >&2
        exit 2
    fi
fi

if [ "$no_modules" -eq 0 ]
then
    # check lib_mod_dir exists
    if [ ! -d "$lib_mod_dir" ]
    then
        echo "Could not find the modules of $kversion_label." >&2
        echo "Directory '$lib_mod_dir' is missing." >&2
        if [ "$mode" = "build" -a "$env_file" = "" ]
        then
            echo "$MESSAGE_SUSPICIOUS_HOST" >&2
            echo >&2
            echo "$MESSAGE_SEE_HELP" >&2
        else
            echo "Aborting." >&2
        fi
        exit 3
    fi

    if [ "$mode" = "build" ]
    then
        # check that lib_mod_dir contains modules
        first_mod="$(find "$lib_mod_dir" -name "*.ko*" -print -quit)"
        if [ -z "$first_mod" ]
        then
            echo "Could not find kernel modules in '$lib_mod_dir'." >&2
            echo "Aborting." >&2
            exit 3
        fi

        # check that we know how to handle kernel modules if compressed
        case "$first_mod" in
            *.ko)
                ;;
            *.ko.zst)
                check_commands zstdcat
                ;;
            *)
                echo "Unexpected module extension" \
                     "'.ko.${first_mod##*.}'" >&2
                echo "Aborting." >&2
                exit 9
                ;;
        esac
    fi
fi

detect_netdev_modules() {
    local d module_dir
    # Detect the kernel modules needed for each interface on the system,
    # and the kernel modules needed for the buses they rely on.
    for d in $(realpath /sys/class/net/*/device 2>/dev/null)
    do
        # Example values for d:
        # - qemu VM netdev:
        #   /sys/devices/pci0000:00/0000:00:02.0/virtio0
        # - PCI-attached netdevs
        #   /sys/devices/pci0000:00/0000:00:1f.6
        #   /sys/devices/pci0000:00/0000:00:1c.2/0000:02:00.0
        # - netdev attached on an external USB hub:
        #   /sys/devices/pci0000:00/0000:00:14.0/usb2/2-6/2-6.4/2-6.4:1.0
        #
        # For a given value of d, we just check all parent directory levels
        # up to /sys/devices (excluded). If a module is needed at a given
        # level, a symlink `driver/module` exists, and running realpath
        # on it returns `/sys/module/<modname>`.
        # Since some modules may be compiled in the kernel, the symlink
        # `driver/module` is not always present.
        while [ "$d" != "/sys/devices" ]
        do
            if [ -L $d/driver/module ]
            then
                realpath $d/driver/module
            fi
            d=$(dirname $d)
        done
    done | sort -u | while read module_dir
    do
       echo "$(basename "$module_dir")"
    done
}

check_elem_in_list() {
    local elem="$1"
    local list="$2"
    case " $list " in
        *" $elem "*)
            return 0  # yes, elem is in list
            ;;
        *)
            return 1  # no
    esac
}

add_mod_deps() {
    local mod="$1" dep_mod

    # only add $mod to $modules if it is the 1st occurence
    if ! check_elem_in_list "$mod" "$modules"
    then
        # nothing to do if the module is builtin
        if check_elem_in_list "$mod" "$mod_builtins"
        then
            return  # module is builtin
        fi

        # check we have seen this module when processing dependencies
        if [ ! -f "$TMP_DIR/mod_deps/$mod" ]
        then
            echo "Could not find a module named '$mod' on this system." >&2
            echo "Aborting." >&2
            exit 7
        fi

        # recursively add dependencies
        for dep_mod in $(cat <"$TMP_DIR/mod_deps/$mod")
        do
            add_mod_deps $dep_mod
        done

        # add the module after its dependencies
        if [ -z "$modules" ]
        then
            modules="$mod"
        else
            modules="$modules $mod"
        fi
    fi
}

detect_modules_and_check() {
    local proto_modules netdev_modules needed_mod mod_builtins needed_file

    for needed_file in "modules.builtin" "modules.dep"
    do
        if [ ! -f "$lib_mod_dir/$needed_file" ]
        then
            echo "Failed: missing '$lib_mod_dir/$needed_file' file." >&2
            exit 7
        fi
    done

    proto_modules="$(proto_modules)"
    netdev_modules="$(detect_netdev_modules)"
    if [ -z "$netdev_modules" ]
    then
        echo "Could not find any ethernet interfaces on this system." >&2
        if [ "$mode" = "build" ]
        then
            echo "$MESSAGE_SUSPICIOUS_HOST" >&2
            echo >&2
        fi
        echo "$MESSAGE_SEE_HELP" >&2
        exit 3
    fi

    mod_builtins=$(
        sed -e "s/[a-zA-Z0-9\/_-]*\///g" -e "s/\.ko$//" \
            -e "s/-/_/g" \
            "$lib_mod_dir/modules.builtin" | \
            tr '\n' ' '
    )

    mkdir "$TMP_DIR/mod_deps"
    sed -e "s/[a-zA-Z0-9\/_-]*\///g" -e "s/\.ko\(\.zst\)\?:*//g" \
        -e "s/-/_/g" \
        "$lib_mod_dir/modules.dep" | \
    while read mod deps
    do
        echo "$deps" > "$TMP_DIR/mod_deps/$mod"
    done

    for needed_mod in $proto_modules $netdev_modules
    do
        add_mod_deps $needed_mod
    done
}

add_module_files() {
    local mod src_mod
    mkdir -p "$rd_rootfs/modules"
    for mod in "$@"
    do
        # see note about MODULE NAMING.
        name_pattern="$(echo "$mod" | sed -e "s/_/[-_]/g")"
        src_mod=$(find "$lib_mod_dir" -name "${name_pattern}.ko*")
        if [ "$src_mod" = "" ]
        then
            echo "Could not find module '$mod' in '$lib_mod_dir'." >&2
            echo "Aborting." >&2
            exit 9
        fi
        case "$src_mod" in
            *.ko.zst)
                zstdcat -d "$src_mod" > "$rd_rootfs/modules/$mod.ko"
                ;;
            *.ko)
                cp "$src_mod" "$rd_rootfs/modules/$mod.ko"
                ;;
        esac
    done
}

copy_exec_to_rootfs()
{
    local exec_path="$(chroot "$rootfs" which "$1")"
    local bin_deps lib destdir
    # copy binary
    mkdir -p bin
    cp "${rootfs}${exec_path}" bin/
    # check needed shared libraries
    if ! bin_deps="$(chroot "$rootfs" ldd "$exec_path" 2>/dev/null)"
    then
        # this executable is probably static, nothing more to do
        return
    fi
    # copy shared libraries
    echo "$bin_deps" | awk '{print $(NF-1)}' | while read lib
    do
        if [ -f "$rootfs/$lib" ]
        then
            destdir="./$(dirname $lib)"
            mkdir -p "$destdir"
            cp "$rootfs/$lib" "$destdir"
        fi
    done
}

build_cpio_archive() {
    local rd_rootfs="$TMP_DIR/rd_rootfs"
    local out_file="$1"
    # copy static initramfs skeleton files
    cp -rp "$THIS_DIR/skeleton" "$rd_rootfs"
    cd $rd_rootfs
    # add protocol-specific mount code
    cp "$THIS_DIR/protocols/${protocol}/mount-functions" .
    # detect modules (unless specified in an env file),
    # add corresponding module files
    # generate the env-file  /env
    if [ "$env_file" = "" ]
    then
        # no env file: detect modules, add corresponding module
        # files, and generate the env file in /env-file.
        if [ "$no_modules" -eq 1 ]
        then
            mkdir $rd_rootfs/modules  # just create an empty dir
        else
            detect_modules_and_check
            add_module_files $modules
        fi
    else
        # env file provided: add corresponding module files
        # and copy the env file to /env-file.
        add_module_files $modules
    fi
    # populate the env-file in rd_rootfs
    echo "MODULES=\"$modules\"" > "env-file"
    echo "KVERSION=\"$kversion\"" >> "env-file"
    echo "PROTOCOL=\"$protocol\"" >> "env-file"
    # copy executables needed
    copy_exec_to_rootfs busybox
    proto_customize_rootfs
    # create the cpio archive
    cd "$rd_rootfs"
    find . | cpio -o -H newc >"$out_file" 2>/dev/null
    cd "$THIS_DIR"
}

check_host_has_exec() {
    if ! chroot "$rootfs" which "$1" >/dev/null
    then
        if [ "$rootfs" = "/" ]
        then
            sysname="This system"
        else
            sysname="The system at '${rootfs}'"
        fi
        echo "${sysname} is missing executable '$1'." >&2
        echo "Aborting." >&2
        exit 8
    fi
}

. "$THIS_DIR/protocols/${protocol}/build-functions"

if [ "$mode" = "build" ]
then
    check_host_has_exec busybox
    proto_check_host
    out_file_dir=$(cd $(dirname "$1") && pwd)
    if [ -z "$out_file_dir" ]
    then
        exit 5
    fi
    out_file="${out_file_dir}/$(basename "$1")"
    if [ "$no_modules" -eq 1 ]
    then
        echo "Building an initramfs with no kernel modules."
    else
        echo "Building an initramfs for kernel version '$kversion'."
    fi
    build_cpio_archive "$out_file"
    echo "'$1' was generated successfully."
fi

if [ "$mode" = "probe" ]
then
    if [ "$no_modules" -eq 0 ]
    then
        # detect modules
        detect_modules_and_check
    fi
    # generate the env file on stdout
    echo "MODULES=\"$modules\""
    echo "KVERSION=\"$(uname -r)\""
    echo "PROTOCOL=\"$protocol\""
fi
